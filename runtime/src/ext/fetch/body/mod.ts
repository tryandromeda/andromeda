// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
// deno-lint-ignore-file no-unused-vars no-explicit-any

/**
 * To extract a body with type from a byte sequence or BodyInit object,
 * with an optional boolean keepalive (default false)
 * @see https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 */
function extractBody(object: any, _keepalive = false) {
  // 1. Let stream be null.
  // deno-lint-ignore prefer-const
  let stream = null;
  // 2. If object is a ReadableStream object, then set stream to object.
  // TODO: implement ReadableStream
  // 3. Otherwise, if object is a Blob object, set stream to the result of running object's get stream.
  // 4. Otherwise, set stream to a new ReadableStream object, and set up stream with byte reading support.
  // 5. Assert: stream is a ReadableStream object.

  // 6. Let action be null.
  // deno-lint-ignore prefer-const
  let _action = null;

  // 7. Let source be null.
  let source = null;

  // 8. Let length be null.
  // deno-lint-ignore prefer-const
  let length = null;

  // 9. Let type be null.
  let type = null;

  // 10. Switch on object:
  if (typeof object == "string") {
    // scalar value string:
    // Set source to the UTF-8 encoding of object.
    // Set type to `text/plain;charset=UTF-8`.
    const encoder = new TextEncoder();
    source = encoder.encode(object);
    type = "text/plain;charset=UTF-8";
    length = source.byteLength;
  } else if (object instanceof Uint8Array) {
    // BufferSource:
    // Set source to a copy of the bytes held by object.
    source = object;
    length = object.byteLength;
  } else if (object instanceof ArrayBuffer) {
    // BufferSource:
    // Set source to a copy of the bytes held by object.
    source = new Uint8Array(object);
    length = object.byteLength;
  } else if (object === null || object === undefined) {
    // null or undefined - no body
    source = null;
  } else {
    console.error("TODO: these are not yet supported");
    // Blob
    // Set source to object.
    // Set length to object's size.
    // If object's type attribute is not the empty byte sequence, set type to its value.

    // FormData:
    // Set action to this step: run the multipart/form-data encoding algorithm, with object's entry list and UTF-8.

    // Set source to object.

    // Set length to unclear, see html/6424 for improving this.

    // Set type to `multipart/form-data; boundary=`, followed by the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.

    // URLSearchParams:
    // Set source to the result of running the application/x-www-form-urlencoded serializer with object's list.

    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.

    // ReadableStream:
    // If keepalive is true, then throw a TypeError.
    // If object is disturbed or locked, then throw a TypeError.
  }

  // 11. If source is a byte sequence, then set action to a step that returns source and length to source's length.

  // 12. If action is non-null, then run these steps in parallel:
  //   1. Run action.
  //      Whenever one or more bytes are available and stream is not errored, enqueue the result of creating a Uint8Array from the available bytes into stream.
  //      When running action is done, close stream.

  // 13. Let body be a body whose stream is stream, source is source, and length is length.
  const body = { stream, source, length };

  // 14. Return (body, type).
  return [body, type];
}
